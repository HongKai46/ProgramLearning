# 差分与前缀和

## 差分

### 定义

若a[i]=b[i]-b[i-1],那么数组a为数组b的差分数组

```c++
for(int i=1;i<=n;i++) a[i]=b[i]-b[i-1];
```

### 作用

将区间操作转化为两点操作

#### e.g

若要将b数组的[l,r]范围内所有值+x，数组a为数组b的差分数组，那么等价于a[l]+=x,a[r+1]-=x

### 性质

差分与前缀和互为逆运算。若数组a为数组b的差分数组，那么数组b为数组a的前缀和数组。

## 前缀和

### 定义

若数组a为数组b的前缀和数组,那么a[1]=b[1],a[i]=a[i-1]+b[i]

```c++
for(int i=1;i<=n;i++) a[i]=a[i-1]+b[i];
```

### 作用

用于求前缀和

### 时间复杂度

查询O(1)，修改O(n)

# 树状数组

## 作用

单点修改，区间查询

## 定义

```c++
void Add(int pos,int x)
{
	while(pos<=n)
	{
		tree[pos]+=x;
		pos+=pos&(-pos);
	}
}
ll Sum(int pos)
{
	ll ret=0;
	while(pos>0)
	{
		ret+=tree[pos];
		pos-=pos&(-pos);
	}
	return ret;
}
```

## 性质

若想实现数组的区间修改和单点查询，可以结合**差分**：

​	Add(i,a[i]-a[i-1])，使用数组a的差分数组创建树状数组，区间修改便可转为两点修改，而单点查询，刚好就是Sum(i),因为差分数组的前缀和就是原数组。

## 复杂度

查询和修改的时间复杂度都是O(logn)

# 动态规划（DP）

## 记忆化搜索（dfs）

### 例题：数字三角形

#### 原理

从下向上累加，一个点的数据能重复用。

从上向下累加，一个点的数据不能重复用

#### 代码实现

```c++
#include<bits/stdc++.h>
using namespace std;
const int n = 4;
int a[9][9]={
	{1},
	{4,6},
	{8,3,9},
	{5,7,2,1}
};
int f[9][9];
int dfs(int x,int y)
{
	if(f[x][y]!=0) return f[x][y];//体现记忆化特性
	if(x==n-1) f[x][y] = a[x][y];
	else f[x][y] = a[x][y] + max(dfs(x+1,y),dfs(x+1,y+1));
	return f[x][y];
}
int main()
{
	ios::sync_with_stdio(0);
	cout<<dfs(0,0);
}
```

实践复杂度：O(n^2)

#### 另解

##### 逆推法

```c++
#include<bits/stdc++.h>
using namespace std;
const int n = 4;
int a[9][9]={
	{1},
	{4,6},
	{8,3,9},
	{5,7,2,1}
};
int b[9][9];
int p[9][9];
int main()
{
	//记录路径
	for(int x=0;x<=n-1;x++)
	{
		for(int y=0;y<=x;y++)
		{
			b[x][y]=a[x][y];
		}
	}
	for(int x=n-2;x>=0;x--)
	{
		for(int y=0;y<=x;y++)
		{
			a[x][y]+=max(a[x+1][y],a[x+1][y+1]);
			if(a[x+1][y]<a[x+1][y+1]) p[x][y]=1;
		}
	}
	cout<<a[0][0]<<"\n";
	//输出路径
	for(int x=0,y=0;x<=n-1;x++)
	{
		if(x>0) cout<<"-->";		
		cout<<b[x][y];
		y+=p[x][y];//用数组记录路径，值得学习
	}
}
```

## 最长上升子序列（LIS）

### DP算法O(n<sup>2</sup>)

**可以实现：**

**1.输出路径**

**2.最长上升子序列的长度**

```c++
#include<bits/stdc++.h>
using namespace std;
const int n = 9;
int a[20] = {5,7,1,9,4,6,2,8,3};
int b[20];
vector<vector<int> > c(20);//用于存储路径
int main()
{
	int Max=0;vector<int> ans;
	for(int i=0;i<n;i++)
	{
		vector<int> ret;
		for(int j=0;j<i;j++)
		{
			if(a[j]<a[i]&&b[j]>=b[i]) 
            	b[i]=b[j]+1,c[i]=c[j];
		}
		c[i].push_back(a[i]);
		if(Max<b[i]) Max=b[i],ans=c[i];
	}
	cout<<Max+1<<"\n";
	for(int i=0;i<(int)ans.size();i++)
	{
		if(i>0) cout<<"-->";
		cout<<ans[i];
	}
}
```

### 贪心+二分查找O(n<sup>2</sup>)

```c++
//洛谷P1020
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5+5;
int a[maxn];
vector<int> b;
//寻找第一个小于x的数
int find1(int x)
{
	int l=0,r=b.size();
	int mid = (l+r)/2;
	while(l+1<r)
	{
		if(b[mid]<x) r=mid;
		else l=mid;
		mid = (l+r)/2;
	}
	if(r==(int)b.size()) return -1;
	return r;
}
//获取最长不增子序列长度
int lis1(int n)
{
	for(int i=0;i<n;i++)
	{
		int r = find1(a[i]);
		if(r==-1) b.push_back(a[i]);
		else b[r] = a[i];
	}
	return b.size()-1;
}
//寻找第一个大于等于x的数
int find2(int x)
{
	int l=0,r=b.size(),mid=(l+r)/2;
	while(l+1<r)
	{
		if(b[mid]>=x) r=mid;
		else l = mid;
		mid = (l+r)/2;
	}
	if(r==(int)b.size()) return -1;
	return r;
}
//获取最长递增子序列长度
int lis2(int n)
{
	for(int i=0;i<n;i++)
	{
		int r = find2(a[i]);
		if(r==-1) b.push_back(a[i]);
		else b[r] = a[i];
	}
	return b.size()-1;
}
int main()
{
	b.push_back(0);
	ios::sync_with_stdio(0);
	int n=0;
	while(cin>>a[n])
	{
		n++;
	}
	cout<<lis1(n)<<"\n";
	b.clear();
	b.push_back(0);	
	cout<<lis2(n)<<"\n";
}
```

## 最长公共子序列

### 代码实现

```c++
#include<bits/stdc++.h>
using namespace std;
string a="ADABEC";
string b="DBDCA";
int mat[10][10];
//mat[i][j]表示字符串a的第i个字符之前和字符串b的第j个字符之前最长公共子序列的长度
//注意下标：mat[1][1]代表a[0]与b[0]之前的（包括a[0],b[0]）
int main()
{
	for(int i=1;i<=(int)a.size();i++)
	{
		for(int j=1;j<=(int)b.size();j++)
		{
			if(a[i-1]==b[j-1]) mat[i][j]=mat[i-1][j-1]+1;
			else mat[i][j]=max(mat[i-1][j],mat[i][j-1]);
		}
	}
	cout<<mat[a.size()][b.size()]<<"\n";
	string ans;
	int x=a.size(),y=b.size();
	//获取路径
	while(x>0&&y>0)
	{
		if(a[x-1]==b[y-1]){
			ans+=a[x-1];
			x--,y--;
		}
		else if(mat[x][y-1]<mat[x-1][y]){
			x--;
		}
		else{
			y--;
		}
	}
	reverse(ans.begin(),ans.end());
	cout<<ans<<"\n";
}
```

## 01背包

### 描述

将x个物品放入容积为y的背包中，每个物品有体积和价值，每个物品只能放一次，求该容积背包的最大价值

### 思路

**状态：**

dp\[i][j] 表示有i个物品放入容量为j的背包中的最大价值

**状态转移：**

1. w<=j时，dp\[i][j] = max(dp\[i-1][j] , dp\[i-1][j-w]+v)
1. w>j时，dp\[i][j] = dp\[i-1][j]

### 代码实现

```c++
#include<bits/stdc++.h>
using namespace std;
int x,y,w,v;
int dp[10];
int main()
{
	ios::sync_with_stdio(0);
	cin>>x>>y;//x为物品数量，y为背包容量
	for(int i=1;i<=x;i++)
	{
		cin>>w>>v;
		for(int j=y;j>0;j--)//逆序：用到的前面的元素是来自上一次循环的元素
		{
			if(w<=j)//条件必要，w>j时只能dp[j]=dp[j]
				dp[j] = max(dp[j],dp[j-w]+v);
		}
	}
	cout<<dp[6];
}
```

## 完全背包

### 描述

与01背包的差别就是完全背包中放入的物品可以有无限个

### 思路

**状态：**

dp\[i][j] 表示有i个物品放入容量为j的背包中的最大价值

**状态转移：**

1. w<=j时，dp\[i][j] = max(dp\[i-1][j] , dp\[i][j-w]+v) 
  >    01背包为max(dp\[i-1][j] , dp\[i-1][j-w]+v)，因为01背包放入一个价值为v的物品时，剩下的j-w空间只能由i-1个其他物品放，而完全背包放入一个后还可以由i个物品放

2. w>j时，dp\[i][j] = dp\[i-1][j]

### 代码实现

```c++
#include<bits/stdc++.h>
using namespace std;
int x,y,w,v;
int dp[10];
int main()
{
	ios::sync_with_stdio(0);
	cin>>x>>y;
	for(int i=1;i<=x;i++)
	{
		cin>>w>>v;
		for(int j=1;j<=y;j++)//只是把01背包的逆序改为正序就是完全背包
		{
			if(w<=j)
				dp[j] = max(dp[j],dp[j-w]+v);
		}
	}
	cout<<dp[6];
}
```

```c++
//这是我自己看教学之前想的一种解决方法，但是显然没有上面那种方法好
#include<bits/stdc++.h>
using namespace std;
int x,y,w,v;
int dp[10];
int main()
{
	ios::sync_with_stdio(0);
	cin>>x>>y;
	for(int i=1;i<=x;i++)
	{
		cin>>w>>v;
		for(int j=y;j>0;j--)
		{
			if(w<=j){
				int t=j;
				while(w<=t)
				{
					t-=w;
					dp[j] = max(dp[j],dp[t-w]+(j-t)/w*v);
				}
			}
		}
	}
	cout<<dp[6];
}
```

## 多重背包

### 描述

与完全背包的差异是每个物品不是无限个，而是指定的数量

### 算法

1.朴素做法：将每个物品拆分为1份，转换为01背包，O(m*∑s(i) ) 

2.二进制拆分优化：将物品数量拆分为二进制数字（1，2，4...）最后可能剩余一个非二进制数。**思路：**最后要得知的是要从物品的总数量中选多少个物品（类比直接拆分为1份然后转为01背包），拆分为的二进制数可以表示1-n的所有数（n为物品数量），最后能够表示选了多少个物品。

# 查找

## 二分查找

### 板子

```c++
//查找第一个大于等于x的数
int find1(int x)
{
	int l=0,r=len;
	int mid = (l+r)/2;
	while(l+1<r)
	{
		if(a[mid]>=x) r=mid;
		else l = mid;
		mid = (l+r)/2;
	}
	return r;
}
//查找最后一个小于等于x的数
int find2(int x)
{
	int l=0,r=len;
	int mid = (l+r)/2;
	while(l+1<r)
	{
		if(a[mid]<=x) l=mid;
		else r = mid;
		mid = (l+r)/2;
	}
	return l;
}
```

**Remark**：

1.假如是降序序列，原理相同（查最后一个大于等于x，第一个小于等于x）

2.假如要求第一个大于x，就是求最后一个小于等于x的元素的前一个（假如存在的话）

### 例子：浮点数二分

**求一个浮点数的三次方根(-10000<x<10000)**

```c++
double find(double x)
{
    float l=-100,r=100;
    float mid = (l+r)/2;
    while(r-l>1e-5)
    {
        if(mid*mid*mid<x) l = mid;
        else r=mid;
    }
    return l;
}
```

例题：洛谷P1024