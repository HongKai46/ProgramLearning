# 差分与前缀和

## 差分

### 定义

若a[i]=b[i]-b[i-1],那么数组a为数组b的差分数组

```c++
for(int i=1;i<=n;i++) a[i]=b[i]-b[i-1];
```

### 作用

将区间操作转化为两点操作

#### e.g

若要将b数组的[l,r]范围内所有值+x，数组a为数组b的差分数组，那么等价于a[l]+=x,a[r+1]-=x

### 性质

差分与前缀和互为逆运算。若数组a为数组b的差分数组，那么数组b为数组a的前缀和数组。

## 前缀和

### 定义

若数组a为数组b的前缀和数组,那么a[1]=b[1],a[i]=a[i-1]+b[i]

```c++
for(int i=1;i<=n;i++) a[i]=a[i-1]+b[i];
```

### 作用

用于求前缀和

### 时间复杂度

查询O(1)，修改O(n)

# 树状数组

## 作用

单点修改，区间查询

## 定义

```c++
void Add(int pos,int x)
{
	while(pos<=n)
	{
		tree[pos]+=x;
		pos+=pos&(-pos);
	}
}
ll Sum(int pos)
{
	ll ret=0;
	while(pos>0)
	{
		ret+=tree[pos];
		pos-=pos&(-pos);
	}
	return ret;
}
```

## 性质

若想实现数组的区间修改和单点查询，可以结合**差分**：

​	Add(i,a[i]-a[i-1])，使用数组a的差分数组创建树状数组，区间修改便可转为两点修改，而单点查询，刚好就是Sum(i),因为差分数组的前缀和就是原数组。

## 复杂度

查询和修改的时间复杂度都是O(logn)

# 动态规划（DP）

## 记忆化搜索（dfs）

### 例题：数字三角形

#### 原理

从下向上累加，一个点的数据能重复用。

从上向下累加，一个点的数据不能重复用

#### 代码实现

```c++
#include<bits/stdc++.h>
using namespace std;
const int n = 4;
int a[9][9]={
	{1},
	{4,6},
	{8,3,9},
	{5,7,2,1}
};
int f[9][9];
int dfs(int x,int y)
{
	if(f[x][y]!=0) return f[x][y];//体现记忆化特性
	if(x==n-1) f[x][y] = a[x][y];
	else f[x][y] = a[x][y] + max(dfs(x+1,y),dfs(x+1,y+1));
	return f[x][y];
}
int main()
{
	ios::sync_with_stdio(0);
	cout<<dfs(0,0);
}
```

实践复杂度：O(n^2)