# 差分与前缀和

## 差分

### 定义

若a[i]=b[i]-b[i-1],那么数组a为数组b的差分数组

```c++
for(int i=1;i<=n;i++) a[i]=b[i]-b[i-1];
```

### 作用

将区间操作转化为两点操作

#### e.g

若要将b数组的[l,r]范围内所有值+x，数组a为数组b的差分数组，那么等价于a[l]+=x,a[r+1]-=x

### 性质

差分与前缀和互为逆运算。若数组a为数组b的差分数组，那么数组b为数组a的前缀和数组。

## 前缀和

### 定义

若数组a为数组b的前缀和数组,那么a[1]=b[1],a[i]=a[i-1]+b[i]

```c++
for(int i=1;i<=n;i++) a[i]=a[i-1]+b[i];
```

### 作用

用于求前缀和

### 时间复杂度

查询O(1)，修改O(n)

# 树状数组

## 作用

单点修改，区间查询

## 定义

```c++
void Add(int pos,int x)
{
	while(pos<=n)
	{
		tree[pos]+=x;
		pos+=pos&(-pos);
	}
}
ll Sum(int pos)
{
	ll ret=0;
	while(pos>0)
	{
		ret+=tree[pos];
		pos-=pos&(-pos);
	}
	return ret;
}
```

## 性质

若想实现数组的区间修改和单点查询，可以结合**差分**：

​	Add(i,a[i]-a[i-1])，使用数组a的差分数组创建树状数组，区间修改便可转为两点修改，而单点查询，刚好就是Sum(i),因为差分数组的前缀和就是原数组。

## 复杂度

查询和修改的时间复杂度都是O(logn)

# 动态规划（DP）

## 记忆化搜索（dfs）

### 例题：数字三角形

#### 原理

从下向上累加，一个点的数据能重复用。

从上向下累加，一个点的数据不能重复用

#### 代码实现

```c++
#include<bits/stdc++.h>
using namespace std;
const int n = 4;
int a[9][9]={
	{1},
	{4,6},
	{8,3,9},
	{5,7,2,1}
};
int f[9][9];
int dfs(int x,int y)
{
	if(f[x][y]!=0) return f[x][y];//体现记忆化特性
	if(x==n-1) f[x][y] = a[x][y];
	else f[x][y] = a[x][y] + max(dfs(x+1,y),dfs(x+1,y+1));
	return f[x][y];
}
int main()
{
	ios::sync_with_stdio(0);
	cout<<dfs(0,0);
}
```

实践复杂度：O(n^2)

#### 另解

##### 逆推法

```c++
#include<bits/stdc++.h>
using namespace std;
const int n = 4;
int a[9][9]={
	{1},
	{4,6},
	{8,3,9},
	{5,7,2,1}
};
int b[9][9];
int p[9][9];
int main()
{
	//记录路径
	for(int x=0;x<=n-1;x++)
	{
		for(int y=0;y<=x;y++)
		{
			b[x][y]=a[x][y];
		}
	}
	for(int x=n-2;x>=0;x--)
	{
		for(int y=0;y<=x;y++)
		{
			a[x][y]+=max(a[x+1][y],a[x+1][y+1]);
			if(a[x+1][y]<a[x+1][y+1]) p[x][y]=1;
		}
	}
	cout<<a[0][0]<<"\n";
	//输出路径
	for(int x=0,y=0;x<=n-1;x++)
	{
		if(x>0) cout<<"-->";		
		cout<<b[x][y];
		y+=p[x][y];//用数组记录路径，值得学习
	}
}
```

## 最长上升子序列（LIS）

# 查找

## 二分查找

### 板子

```c++
//查找第一个大于等于x的数
int find1(int x)
{
	int l=0,r=len;
	int mid = (l+r)/2;
	while(l+1<r)
	{
		if(a[mid]>=x) r=mid;
		else l = mid;
		mid = (l+r)/2;
	}
	return r;
}
//查找最后一个小于等于x的数
int find2(int x)
{
	int l=0,r=len;
	int mid = (l+r)/2;
	while(l+1<r)
	{
		if(a[mid]<=x) l=mid;
		else r = mid;
		mid = (l+r)/2;
	}
	return l;
}
```

**Remark**：

1.假如是降序序列，原理相同（查最后一个大于等于x，第一个小于等于x）

2.假如要求第一个大于x，就是求最后一个小于等于x的元素的前一个（假如存在的话）

### 例子：浮点数二分

**求一个浮点数的三次方根(-10000<x<10000)**

```c++
double find(double x)
{
    float l=-100,r=100;
    float mid = (l+r)/2;
    while(r-l>1e-5)
    {
        if(mid*mid*mid<x) l = mid;
        else r=mid;
    }
    return l;
}
```

例题：洛谷P1024